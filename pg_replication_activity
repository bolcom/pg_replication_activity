#!/usr/bin/env python
"""
pg__replication_activity
author: Sebastiaan Mannem <sebas@mannem.nl>
license: PostgreSQL License

Copyright (c) 2012 - 2018, S. Mannem

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose, without fee, and without a written
agreement is hereby granted, provided that the above copyright notice
and this paragraph and the following two paragraphs appear in all copies.

IN NO EVENT SHALL SEBASTIAAN MANNEM BE LIABLE TO ANY PARTY FOR
DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
EVEN IF SEBASTIAAN MANNEM HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

SEBASTIAAN MANNEM SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS"
BASIS, AND SEBASTIAAN MANNEM HAS NO OBLIGATIONS TO PROVIDE
MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
"""


import os
import sys
import signal
import argparse
import socket
import curses
import psycopg2
from psycopg2 import errorcodes

from pgreplicationactivity import UI, pgconnection

PGTOP_VERSION = "0.0.1"

if os.name != 'posix':
    sys.exit("FATAL: Platform not supported.")

# Create the UI
PGAUI = UI.UI(PGTOP_VERSION)


def get_arguments():
    """
    Run argparse and return arguments
    """
    try:
        # Use argparse to handle devices as arguments
        description = 'htop like application for PostgreSQL replication ' + \
                      'activity monitoring.'
        parser = argparse.ArgumentParser(description=description,
                                         add_help=False)

        # Only use --help for help, to preserve -h for --host
        parser.add_argument(
            '--help',
            dest='help',
            action='store_true',
            help='show this help message and exit')

        # -c / --connectstring
        parser.add_argument(
            '-c',
            '--connectstring',
            dest='constr',
            default='',
            help='Connectstring (default: "").',
            metavar='CONNECTSTRING')
        # -U / --username
        parser.add_argument(
            '-U',
            '--username',
            dest='username',
            default='',
            help='Database user name (default: "").',
            metavar='USERNAME')
        # -p / --port
        parser.add_argument(
            '-p',
            '--port',
            dest='port',
            default='',
            help='Database server port (default: "").',
            metavar='PORT')
        # -h / --host
        parser.add_argument(
            '-h',
            '--host',
            dest='host',
            default='',
            help='Database server host or socket directory (default: "").',
            metavar='HOSTNAME')
        # -d / --dbname
        parser.add_argument(
            '-d',
            '--dbname',
            dest='dbname',
            help='Database name to connect to (default: "").',
            metavar='DBNAME',
            default='')
        # -C / --no-color
        parser.add_argument(
            '-C',
            '--no-color',
            dest='nocolor',
            action='store_true',
            help="Disable color usage.",
            default='false')
        # --blocksize
        parser.add_argument(
            '--blocksize',
            dest='blocksize',
            help="Filesystem blocksize (default: 4096)",
            metavar='BLOCKSIZE',
            default=4096)
        # --rds
        parser.add_argument(
            '--rds',
            dest='rds',
            action='store_true',
            help="Enable support for AWS RDS",
            default='false')
        group = parser.add_argument_group(
            "Display options",
            "Display Options, you can exclude some columns by using them ")
        # --no-database
        group.add_argument(
            '--no-database',
            dest='nodb',
            action='store_true',
            help="Disable DATABASE.",
            default='false')
        # --no-user
        group.add_argument(
            '--no-user',
            dest='nouser',
            action='store_true',
            help="Disable USER.",
            default='false')
        # --no-client
        group.add_argument(
            '--no-client',
            dest='noclient',
            action='store_true',
            help="Disable CLIENT.",
            default='false')
        # --no-cpu
        group.add_argument(
            '--no-cpu',
            dest='nocpu',
            action='store_true',
            help="Disable CPU.",
            default='false')
        # --no-mem
        group.add_argument(
            '--no-mem',
            dest='nomem',
            action='store_true',
            help="Disable MEM.",
            default='false')
        # --no-read
        group.add_argument(
            '--no-read',
            dest='noread',
            action='store_true',
            help="Disable READ/s.",
            default='false')
        # --no-write
        group.add_argument(
            '--no-write',
            dest='nowrite',
            action='store_true',
            help="Disable WRITE/s.",
            default='false')
        # --no-time
        group.add_argument(
            '--no-time',
            dest='notime',
            action='store_true',
            help="Disable TIME+.",
            default='false')
        # --no-wait
        group.add_argument(
            '--no-wait',
            dest='nowait',
            action='store_true',
            help="Disable W.",
            default='false')
        # --debug
        parser.add_argument(
            '-x',
            '--debug',
            dest='debug',
            action='store_true',
            help="Enable debug mode for traceback tracking.",
            default='false')
        args = parser.parse_args()
    except (argparse.ArgumentError, argparse.ArgumentTypeError) as err:
        print('pg_activity: error: %s' % str(err))
        print('Try "pg_activity --help" for more information.')
        sys.exit(1)
    if args.help:
        parser.print_help()
        sys.exit()
    return args


def main():
    '''
    Main procedure
    '''
    args = get_arguments()
    try:
        password = os.environ.get('PGPASSWORD')
        debug = args.debug
        nb_try = 0
        while nb_try < 2:
            try:
                dsn = pgconnection.connstr_to_dsn(args.constr)
                if args.host:
                    dsn['host'] = args.host
                if args.port:
                    dsn['port'] = args.port
                if args.username:
                    print(args.username)
                    dsn['user'] = args.username
                if password:
                    dsn['password'] = password
                if args.dbname:
                    dsn['dbname'] = args.dbname
                print(dsn)
                PGAUI.data = pgconnection.PGMultiConnection(dsn)
                PGAUI.data.connect()
                break
            except psycopg2.OperationalError as err:
                msg = str(err).strip()
                if msg.startswith("FATAL:  password authentication failed "
                                  "for user"):
                    is_password_error = True
                elif err.pgcode == errorcodes.INVALID_PASSWORD:
                    is_password_error = True
                elif msg == "fe_sendauth: no password supplied":
                    is_password_error = True
                else:
                    is_password_error = False

                if is_password_error and nb_try < 1:
                    nb_try += 1
                    password = UI.ask_password()
                else:
                    sys.exit("pg_activity: FATAL: %s" %
                             (UI.clean_str(str(err),)))

        hostname = socket.gethostname()
        # top part
        interval = 0
        if PGAUI.get_mode() == 'lag':
            lag_info = PGAUI.data.get_standby_info()
        # draw the flag
        flag = UI.get_flag_from_options(args)
        # main loop
        disp_procs = None
        delta_disk_io = {'write_bytes': 0, 'read_bytes': 0, 'read_count': 0, 'write_count': 0}
        # indentation
        indent = PGAUI.get_indent(flag)
        # Init curses
        PGAUI.init_curses()
        # color ?
        if args.nocolor is True:
            PGAUI.set_nocolor()
        else:
            PGAUI.set_color()
        while 1:
            PGAUI.check_window_size()
            old_pgtop_mode = PGAUI.get_mode()
            # poll process
            (disp_procs, new_lag_info) = PGAUI.poll(interval, flag, indent,
                                                    lag_info, disp_procs)
            if PGAUI.get_mode() != old_pgtop_mode:
                indent = PGAUI.get_indent(flag)
            lag_info = new_lag_info
            # get active connections
            PGAUI.set_buffer({
                'procs': disp_procs,
                'extras': (
                    PGAUI.data.get_pg_version(),
                    hostname,
                    args.username,
                    args.host,
                    args.port,
                    args.dbname),
                'flag': flag,
                'indent': indent,
                'io': delta_disk_io,
                'tps': 9,
                'active_connections': 10,
                'size_ev': 100,
                'total_size': 1000
            })
            # refresh
            PGAUI.refresh_window(
                disp_procs,
                (
                    PGAUI.data.get_pg_version(),
                    hostname,
                    args.username,
                    args.host,
                    args.port,
                    args.dbname),
                flag,
                indent,
                delta_disk_io,
                9,
                10,
                100,
                1000
            )
            interval = 1

    except curses.error as err:
        PGAUI.at_exit_curses()
        if debug is True:
            import traceback
            exc_type, exc_value, exc_traceback = sys.exc_info()
            traceback.print_exception(
                exc_type,
                exc_value,
                exc_traceback,
                file=sys.stdout)
        sys.exit("FATAL: %s" % (str(err),))
    except KeyboardInterrupt as err:
        PGAUI.at_exit_curses()
        sys.exit(1)
    except Exception as err:
        PGAUI.at_exit_curses()
        # DEBUG
        if args.debug is True:
            import traceback
            exc_type, exc_value, exc_traceback = sys.exc_info()
            traceback.print_exception(
                exc_type,
                exc_value,
                exc_traceback,
                file=sys.stdout)
        sys.exit("FATAL: %s" % (str(err),))


# Call the main function
if __name__ == '__main__':
    signal.signal(signal.SIGTERM, PGAUI.signal_handler)
    main()
